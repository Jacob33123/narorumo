#summary Questions from the IU CS qualifier in Systems, 2006
#labels Quals

= One: Threads =
== a ==
Which of the following items are typically considered to be unique to a process, but not unique to a thread?
  * CPU registers
  * page table pointer
  * stack pointer
  * open files
  * segment table
  * child processes
  * program counter

== b ==
Which of the following are true statements about user-level threads versus kernel-level threads?
  * Invoking any system call that might block poses an extra problem for user-level threads
  * User level threads are more vulnerable to priority inversion than kernel-level threads
  * There is less overall scheduling overhead in a user-level thread system
  * User level threads retain advantages on symmetric multiprocessors
  * Upcalls are necessary to implement user-level threads. (An upcall is a notification, provided by the kernel to the user-level thread run-time system, that a thread has blocked.)

= Two: CPU Efficiency =
Measurements of a certain system have shown that the average process runs for a time T before blocking on I/O. A process switch requires time S, which is effectively wasted (over-head). For round-robin scheduling with quantum Q, give a formula for the CPU efficiency for each of the following.
  * Q = infinity
  * Q > T
  * S < Q < T
  * Q = S
  * Q nearly 0

= Three: Semaphores =
Suppose we have two threads Ta and Tb that we would like to wait for each other at a certain point in their execution

=== Thread Ta ===
statement a1
rendezvous_a()
statement a2

=== Thread Tb ===
statement b1
rendezvous_b()
statement b2

Here, we want Ta not to execute a2 until Tb has executed b1 and we want Tb not to execute b2 until Ta has executed a1. That is, we want the threads to "rendezvous" by calling rendezvous_a() and rendezvous_b().

Give a semaphore-based solution for rendezvous_a() and rendezvous_b(). Declare any variables you might need, along with their initial values. Make sure that deadlock is not possible in your solution.