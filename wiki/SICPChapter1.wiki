#summary SICP Chapter 1

= SICP Chapter 1=

== Progress ==

|| number || status ||
|| 1      || not started ||
|| 2      || done ||
|| 3      || done ||
|| 4      || done ||
|| 5      || done ||
|| 6      || done ||
|| 7      || done ||
|| 8      || done ||
|| 9      || done ||
|| 10     || done ||
|| 11     || done ||
|| 12     || done ||
|| 13     || done ||
|| 14     || done ||
|| 15     || done ||
|| 16     || done ||
|| 17     || done ||
|| 18     || done ||
|| 19     || done ||
|| 20     || done ||
|| 21     || done ||
|| 22     || done ||
|| 23     || done ||
|| 24     || mostly done ||
|| 25     || done ||
|| 26     || done ||
|| 27     || done ||
|| 28     || done ||
|| 29     || done ||
|| 30     || done ||
|| 31     || done ||
|| 32     || done ||
|| 33     || not started ||
|| 34     || done ||
|| 35     || not started ||
|| 36     || not started ||
|| 37     || not started ||
|| 38     || not started ||
|| 39     || not started ||
|| 40     || not started ||
|| 41     || not started ||
|| 42     || not started ||
|| 43     || not started ||
|| 44     || not started ||
|| 45     || not started ||
|| 46     || not started ||
|| 47     || not started ||

== Considerations ==
  * Applicative-order evaluation is clearly the same as "eager evaluation", and normal-order seems to be the same as lazy evaluation -- but is this the same thing as passing a thunk? What's the relationship there?

== Problems ==

Okay, I see what was going wrong in 1.16 in my [http://code.google.com/p/narorumo/source/diff?r=57&format=side&path=/trunk/sicp/chapter1.scm last commit].  My procedure was computing iteratively AND recursively and MULTIPLYING the products, so that 2^1^ = 4, 2^2^ = 16, 2^3^ = 64, 2^4^ = 256, et cetera.  Badness!  I wish I were better at thinking iteratively.

Here's what an example expansion looked like in the buggy version:

{{{
(fast-expt-iter 2 4)
(fast-expt-iter-kernel 2 4 1)
(* 2 (fast-expt-iter-kernel 2 3 2))
(* 2 (* 2 (fast-expt-iter-kernel 2 2 4)))
(* 2 (* 2 (* 2 (fast-expt-iter-kernel 2 1 8))))
(* 2 (* 2 (* 2 (* 2 (fast-expt-iter-kernel 2 0 16)))))
(* 2 (* 2 (* 2 (* 2 16))))
(* 2 (* 2 (* 2 32)))
(* 2 (* 2 64))
(* 2 128)
256
}}}


So, the the value of /a/ is correct at the end (a = 16), but then we're doing all the backed-up multiplications for the recursion, too!  Oh, noes!

On the plus side, now I'll know exactly to do if my students make this mistake:
"Lindsey!  My code is acting sort of wrong.  Everything's coming out the SQUARE of what it's supposed to be."
"Interesting!  What do you think might cause it to do that?"
"I got the state transformation for the iteration wrong."
"No, you got that part right."
"But--"
"You got the iteration right."
"Okay, then I got the recursion wrong."
"You got the recursion right."
"But if I--if both--what--oh."