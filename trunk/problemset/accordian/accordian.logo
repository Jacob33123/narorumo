;; A card is represented as a word, two chars long. Ten of clubs is TC.

to rungame :stacks
  make "stepped (astep :stacks)
  if (:stepped = :stacks) [ output :stacks ]

  output (rungame :stepped)
end

;; fput is cons.
to astep :stacks
  if (stacks = []) [ output [] ]

  if (count stacks) >= 4 [ output astep.four stacks ]

  if (count stacks) >= 2 [ output astep.two stacks ]

  output fput (first stacks) (astep butfirst stacks)
end

to astep.four :stacks
  make "a (first (item 1 :stacks))
  make "as (butfirst (item 1 :stacks))

  make "b (first (item 2 :stacks))
  make "bs (butfirst (item 2 :stacks))

  make "c (first (item 3 :stacks))
  make "cs (butfirst (item 3 :stacks))

  make "d (first (item 4 :stacks))
  make "ds (butfirst (item 4 :stacks))

  make "rest (drop 4 :stacks)

  if (matches :b :a) [
    output nonempty 
              (sentence (list (fput :b (fput :a :as))
                              :bs
                              (fput :c :cs)
                              (fput :d :ds))
                        rest)]

  if (matches :c :b) [
    output nonempty 
              (sentence (list (fput :a :as)
                              (fput :c (fput :b :bs))
                              :cs
                              (fput :d :ds))
                        rest)]
  if (matches :d :a) [
    output nonempty 
              (sentence (list (fput :d (fput :a :as))
                              (fput :b :bs)
                              (fput :c :cs)
                              :ds)
                        rest)]

  output fput (first stacks) (astep butfirst stacks)
end

to astep.two :stacks
  make "a (first (item 1 :stacks))
  make "as (butfirst (item 1 :stacks))

  make "b (first (item 2 :stacks))
  make "bs (butfirst (item 2 :stacks))

  make "rest drop 2 :stacks

  if (matches :b :a) [
    output nonempty 
              (sentence (list (fput :b (fput :a :as))
                              :bs)
                        rest)]

  output fput (first stacks) (astep butfirst stacks)
end

to matches :c1 :c2
  output or ((first c1) = (first c2)) ((second c1) = (second c2))
end

to second :lst
  output item 2 lst
end

to nonEmpty :lst
  output (filter [not emptyp ?] :lst)
end

to drop :n :lst
  if (:n > count :lst) [ (throw "error [trying to drop too many elements]) ]
  
  if (:n = 0) [ output :lst ]
  output (drop (:n - 1) (butfirst :lst))
end

to listToStacks :lst
  output map [ fput ? [] ] lst
end

make "stacksoflose (listToStacks [QD AD 8H 5S 3H 5H TC 4D JH KS 6H 8S JS AC AS
8D 2H QS TS 3S AH 4H TH TD 3C 6S 8C 7D 4C 4S 7S 9H 7C 5D 2S KD 2D QH JD 6D 9D
JC 2C KH 3D QC 6C 9S KC 7H 9C 5C])

make "stacksofwin (listToStacks [AC 2C 3C 4C 5C 6C 7C 8C 9C TC JC QC KC AD 2D
3D 4D 5D 6D 7D 8D TD 9D JD QD KD AH 2H 3H 4H 5H 6H 7H 8H 9H KH 6S QH TH AS 2S
3S 4S 5S JH 7S 8S 9S TS JS QS KS])
